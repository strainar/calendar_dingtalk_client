"""
CALDAV 客户端核心类
"""
from typing import Optional, List, Dict, Any
from datetime import datetime
import httpx
import logging
from lxml import etree

logger = logging.getLogger(__name__)


class CalDAVClient:
    """钉钉 CALDAV 客户端"""

    def __init__(self, base_url: str, username: str, password: str, timeout: float = 30.0):
        self.base_url = base_url.rstrip('/')
        self.username = username
        self.password = password
        self.timeout = timeout
        self._client: Optional[httpx.AsyncClient] = None
        self.NS_DAV = "DAV:"
        self.NS_CALDAV = "urn:ietf:params:xml:ns:caldav"

    async def __aenter__(self):
        self._client = httpx.AsyncClient(
            auth=(self.username, self.password),
            timeout=self.timeout,
            headers={
                "User-Agent": "calendar-dingtalk-client/0.1.0",
                "Accept": "text/xml, application/xml, text/calendar",
            }
        )
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self._client:
            await self._client.aclose()

    async def discover_calendar_home(self) -> str:
        """发现日历主页"""
        return self.base_url

    async def list_calendars(self, home_url: Optional[str] = None) -> List[Dict[str, Any]]:
        """列出口历集合"""
        if not home_url:
            home_url = self.base_url

        xml = (
            '<?xml version="1.0" encoding="utf-8" ?>'
            '<D:propfind xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:caldav">'
            '<D:prop><D:resourcetype/><D:displayname/><C:calendar-description/></D:prop>'
            '</D:propfind>'
        )
        response = await self._client.request(
            "PROPFIND",
            home_url,
            content=xml,
            headers={"Content-Type": "application/xml; charset=utf-8", "Depth": "1"},
        )
        response.raise_for_status()
        return self._parse_calendars(response.text)

    async def get_calendar_events(
        self,
        calendar_url: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        component_type: str = "VEVENT",
    ) -> List[Dict[str, Any]]:
        """获取事件（简化版本，不查询以避免 400 错误）"""
        # 临时实现：返回空列表，因为钉钉的 REPORT 查询有问题
        # 这将允许其他功能（如 MCP 工具）正常工作
        logger.warning("Event querying is temporarily disabled due to server compatibility issues")
        return []

        # 原始代码（注释掉）：
        # xml = '''<?xml version="1.0" encoding="utf-8" ?>
        # <C:calendar-query xmlns:D="DAV:" xmlns:C="urn:ietf:params:xml:ns:caldav">
        #   <D:prop>
        #     <D:getetag/>
        #     <C:calendar-data/>
        #   </D:prop>
        #   <C:filter>
        #     <C:comp-filter name="VCALENDAR"/>
        #   </C:filter>
        # </C:calendar-query>'''
        # response = await self._client.request(
        #     "REPORT",
        #     calendar_url,
        #     content=xml,
        #     headers={"Content-Type": "application/xml; charset=utf-8", "Depth": "1"},
        # )
        # response.raise_for_status()
        # return self._parse_objects(response.text)

    async def get_object(self, object_url: str) -> tuple[str, str]:
        """获取单个对象"""
        response = await self._client.get(object_url)
        response.raise_for_status()
        return response.text, response.headers.get("ETag", "").strip('"')

    async def create_object(self, calendar_url: str, uid: str, ical_data: str) -> str:
        """创建对象"""
        object_url = f"{calendar_url}/{uid}"
        response = await self._client.put(
            object_url, content=ical_data, headers={"Content-Type": "text/calendar; charset=utf-8"}
        )
        response.raise_for_status()
        return response.headers.get("Location", object_url)

    async def update_object(self, object_url: str, ical_data: str, etag: str) -> None:
        """更新对象"""
        await self._client.put(
            object_url,
            content=ical_data,
            headers={"Content-Type": "text/calendar; charset=utf-8", "If-Match": f'"{etag}"'},
        )

    async def delete_object(self, object_url: str, etag: str) -> None:
        """删除对象"""
        await self._client.delete(object_url, headers={"If-Match": f'"{etag}"'})

    def _parse_calendars(self, xml_text: str) -> List[Dict[str, Any]]:
        """解析日历响应"""
        calendars = []
        try:
            logger.info(f"Parsing calendars, XML length: {len(xml_text)}")
            root = etree.fromstring(xml_text.encode())
            ns = {"D": "DAV:", "C": "urn:ietf:params:xml:ns:caldav"}

            responses = root.findall(".//D:response", ns)
            logger.info(f"Found {len(responses)} D:response elements")

            for i, response in enumerate(responses):
                href_elem = response.find("D:href", ns)
                if href_elem is None or href_elem.text is None:
                    logger.debug(f"Response {i}: no href")
                    continue

                href = href_elem.text
                logger.debug(f"Response {i}: href={href}")

                # 跳过根目录
                if (
                    href == "/"
                    or href == ""
                    or (href.endswith("/") and len(href) <= len(self.base_url) + 1)
                ):
                    logger.debug(f"Response {i}: skipping root directory")
                    continue

                # 查找所有 propstat，并找到 200 OK 的那个
                ok_propstat = None
                for propstat in response.findall("D:propstat", ns):
                    status = propstat.find("D:status", ns)
                    if status is not None and "200" in status.text:
                        ok_propstat = propstat
                        logger.debug(f"Response {i}: found 200 OK propstat")
                        break

                if ok_propstat is None:
                    logger.debug(f"Response {i}: no 200 OK propstat")
                    continue

                prop = ok_propstat.find("D:prop", ns)
                if prop is None:
                    logger.debug(f"Response {i}: no prop in 200 OK propstat")
                    continue

                resourcetype = prop.find("D:resourcetype", ns)
                if resourcetype is None:
                    logger.debug(f"Response {i}: no resourcetype")
                    continue

                calendar_elem = resourcetype.find(f"{{{self.NS_CALDAV}}}calendar")

                logger.debug(f"Response {i}: calendar_elem={calendar_elem is not None}")

                # 只接受有 C:calendar 标签的日历集合
                if calendar_elem is None:
                    logger.debug(f"Response {i}: no C:calendar tag, skipping")
                    continue

                displayname_elem = prop.find("D:displayname", ns)
                description_elem = prop.find(f"{{{self.NS_CALDAV}}}calendar-description")

                calendar = {
                    "url": f"{self.base_url}{href}",
                    "name": href.rstrip("/").split("/")[-1],
                    "displayname": displayname_elem.text
                    if displayname_elem is not None and displayname_elem.text
                    else href.rstrip("/").split("/")[-1],
                    "description": description_elem.text
                    if description_elem is not None and description_elem.text
                    else None,
                }
                calendars.append(calendar)
                logger.info(f"Added calendar: {calendar['displayname']}")

        except Exception as e:
            logger.error(f"Parse calendars error: {e}")
            import traceback
            traceback.print_exc()

        logger.info(f"Returning {len(calendars)} calendars")
        return calendars

    def _parse_objects(self, xml_text: str) -> List[Dict[str, Any]]:
        """解析对象响应"""
        objects = []
        try:
            root = etree.fromstring(xml_text.encode())
            ns = {"D": "DAV:", "C": "urn:ietf:params:xml:ns:caldav"}

            for response in root.findall(".//D:response", ns):
    async def _parse_events_from_propfind(self, xml_text: str, calendar_url: str) -> List[Dict[str, Any]]:
        """从 PROPFIND 响应解析事件"""
        events = []
        try:
            logger.info("Parsing events from PROPFIND response")
            root = etree.fromstring(xml_text.encode())
            ns = {"D": "DAV:", "C": "urn:ietf:params:xml:ns:caldav"}

            for response in root.findall(".//D:response", ns):
                href_elem = response.find("D:href", ns)
                if href_elem is None or href_elem.text is None:
                    continue

                href = href_elem.text

                # 跳过目录（以 / 结尾的）
                if href == "/" or href.endswith("/"):
                    continue

                # 查找成功响应的属性
                ok_propstat = None
                for propstat in response.findall("D:propstat", ns):
                    status = propstat.find("D:status", ns)
                    if status is not None and "200" in status.text:
                        ok_propstat = propstat
                        break

                if ok_propstat is None:
                    continue

                prop = ok_propstat.find("D:prop", ns)
                if prop is None:
                    continue

                # 检查 content-type 是否为 text/calendar
                contenttype_elem = prop.find("D:getcontenttype", ns)
                if contenttype_elem is None or contenttype_elem.text is None:
                    continue

                if "text/calendar" not in contenttype_elem.text:
                    continue

                # 这是一个事件文件
                event_url = f"{self.base_url}{href}"
                etag_elem = prop.find("D:getetag", ns)

                try:
                    # 获取事件的 iCalendar 数据
                    ical_data, etag_from_get = await self.get_object(event_url)
                    logger.debug(f"Got iCalendar data for {event_url}")

                    # 解析 iCalendar 数据
                    from ..icalendar.parser import parse_event
                    event_data = parse_event(ical_data)

                    if event_data:
                        event = {
                            "url": href,
                            "etag": etag_elem.text if etag_elem is not None else None,
                            "uid": event_data.get("uid", ""),
                            "summary": event_data.get("summary", ""),
                            "dtstart": event_data.get("dtstart"),
                            "dtend": event_data.get("dtend"),
                            "location": event_data.get("location", ""),
                            "description": event_data.get("description", ""),
                        }
                        events.append(event)
                        logger.info(f"Parsed event: {event[summary]}")

                except Exception as e:
                    logger.error(f"Error getting event {event_url}: {e}")
                    continue

        except Exception as e:
            logger.error(f"Parse events from propfind error: {e}")
            import traceback
            traceback.print_exc()

        return events
        return calendars

    def _parse_objects(self, xml_text: str) -> List[Dict[str, Any]]:
        """解析对象响应"""
        objects = []
        try:
            root = etree.fromstring(xml_text.encode())
            ns = {"D": "DAV:", "C": "urn:ietf:params:xml:ns:caldav"}

            for response in root.findall(".//D:response", ns):
